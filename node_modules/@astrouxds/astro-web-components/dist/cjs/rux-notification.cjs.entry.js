'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-7f00b6e7.js');

const ruxNotificationCss = ":host{--notification-text-color:var(--color-global-tertiary-900);display:flex;justify-content:space-between;flex-wrap:nowrap;flex-grow:1;align-items:center;align-content:center;top:-4.375rem;left:0;height:4.375rem;width:100%;position:absolute;padding:0 1.25rem;background-color:var(--color-global-status-standby-400);transition:top 0.5s ease;box-sizing:border-box;font-family:var(--font-heading-5-font-family);font-size:var(--font-heading-5-font-size);font-weight:var(--font-heading-5-font-weight);letter-spacing:var(--font-heading-5-letter-spacing);color:var(--notification-text-color)}:host rux-icon{align-items:center;justify-content:flex-end;color:var(--color-banner-clear)}:host([hidden]){display:none}:host(.rux-notification-banner-0ba5409c--open){top:0}:host,:host([status=off]){background-color:var(--color-global-status-off-400)}:host([status=standby]){background-color:var(--color-global-status-standby-400)}:host([status=normal]){background-color:var(--color-global-status-normal-400)}:host([status=caution]){background-color:var(--color-global-status-caution-400)}:host([status=serious]){background-color:var(--color-global-status-serious-500)}:host([status=critical]){background-color:var(--color-global-status-critical-400)}";

const RuxNotification = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.ruxClosed = index.createEvent(this, "ruxclosed", 7);
    /**
     *  Set to true to display the Banner and begin countdown to close (if a close-after Number value is provided).
     */
    this.open = false;
    /**
     *  Message for the notification banner.
     */
    this.message = '';
    /**
     *  The background color. Possible values include 'off', 'standby', 'normal', 'caution', 'serious' and 'critical'. See [Astro UXDS Status System](https://astrouxds.com/patterns/status-system/).
     */
    this.status = 'standby';
    this._timeoutRef = null;
  }
  watchHandler() {
    this._updated();
    if (!this.open) {
      this.ruxClosed.emit();
    }
  }
  connectedCallback() {
    this._updated();
  }
  _updated() {
    if (this._closeAfter && this.open) {
      this._timeoutRef = window.setTimeout(() => {
        this.open = false;
      }, this._closeAfter);
    }
  }
  _onClick() {
    if (this._timeoutRef) {
      clearTimeout(this._timeoutRef);
    }
    this.open = false;
  }
  get _closeAfter() {
    //* as long as it's less than 1000, they put in seconds. Convert that here.
    if (this.closeAfter && this.closeAfter <= 999) {
      //it's in seconds
      this.closeAfter *= 1000; // change into ms
    }
    if ((this.closeAfter && this.closeAfter > 10000) ||
      (this.closeAfter && this.closeAfter < 2000)) {
      // if this number is larger than 10s or smaller than 2s, enforce minimum 2s delay
      this.closeAfter = 2000;
    }
    return this.closeAfter;
  }
  render() {
    return (
    /**
     * Add a randomly generated class name when the banner is open
     * so that we can achieve backwards compatibility if anybody is
     * styling the host element.
     *
     * We shouldn't be changing the component's class because the developer
     * has full control of it and can easily override it. But by using
     * a random string, we reduce the chances of that happening unknowingly.
     */
    index.h(index.Host, { class: {
        'rux-notification-banner-0ba5409c--open': this.open,
      } }, index.h("div", { class: "rux-notification__message" }, `${this.message}`), index.h("rux-icon", { role: "button", label: "Close notification", onClick: () => this._onClick(), icon: "close", size: "36px" })));
  }
  static get watchers() { return {
    "open": ["watchHandler"]
  }; }
};
RuxNotification.style = ruxNotificationCss;

exports.rux_notification = RuxNotification;
