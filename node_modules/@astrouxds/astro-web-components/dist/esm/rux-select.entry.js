import { r as registerInstance, c as createEvent, h, H as Host, g as getElement } from './index-01dd0ed8.js';
import { F as FormFieldMessage } from './FormFieldMessage-51640ee4.js';
import { h as hasSlot, r as renderHiddenInput } from './utils-0acfdbb3.js';

const ruxSelectCss = ".rux-help-text{margin-top:0.625rem;color:var(--color-default-text);font-size:var(--font-body-2-font-size);font-family:var(--font-body-2-font-family);font-weight:var(--font-body-2-font-weight);letter-spacing:var(--font-body-2-letter-spacing)}.rux-error-text{padding-left:1.625rem;background-image:url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20128%20128%22%3E%0A%20%20%3Cpath%20fill%3D%22%23FF3030%22%20fill-rule%3D%22evenodd%22%20d%3D%22M64.031%205c8.461%200%2068.88%20107.243%2063.648%20114.184-5.232%206.942-120.805%205.477-127.212%200C-5.941%20113.708%2055.57%205%2064.03%205zm3.45%2075.894l1.822-34.893H56.946l1.82%2034.893h8.715zM56.803%2093.108c0%201.929.547%203.423%201.643%204.483%201.095%201.06%202.642%201.589%204.642%201.589%201.953%200%203.477-.542%204.572-1.625%201.095-1.084%201.643-2.566%201.643-4.447%200-1.952-.542-3.452-1.625-4.5-1.084-1.047-2.613-1.571-4.59-1.571-2.047%200-3.607.512-4.678%201.536-1.072%201.023-1.607%202.535-1.607%204.535z%22%2F%3E%0A%3C%2Fsvg%3E);background-repeat:no-repeat;background-size:1rem;background-position:center left 0rem;text-align:left;width:fit-content;-webkit-order:3;order:3;margin-top:0.625rem;color:var(--color-status-critical-fill);font-size:var(--font-body-2-bold-font-size);font-family:var(--font-body-2-bold-font-family);font-weight:var(--font-body-2-bold-font-weight);letter-spacing:var(--font-body-2-bold-letter-spacing)}:host{display:block;--select-menu-border-radius:var(--radius-base);--select-menu-border-hover-color:var(--color-hover);--select-menu-border-focus-color:var(--color-hover);--select-menu-invalid-border-color:var(--color-status-critical-fill);--select-menu-text-color:var(--color-primary);--select-menu-option-text-hover-color:var(--color-hover);--select-menu-option-selected-background-color:var(--color-selected);--select-menu-option-selected-text-color:var(--color-default-text);--select-menu-label-color:var(--color-default-text);--select-menu-inactive-caret:url(\"data:image/svg+xml,%3Csvg%20width%3D%2210%22%20height%3D%225%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20fill%3D%22%234dacff%22%20d%3D%22M0%200h10L5%205z%22%20fill-rule%3D%22evenodd%22%2F%3E%3C%2Fsvg%3E\");--select-menu-active-caret:url(\"data:image/svg+xml,%3Csvg%20width%3D%2210%22%20height%3D%225%22%20style%3D%22transform%3A%20rotate%28180deg%29%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20fill%3D%22%234dacff%22%20d%3D%22M0%200h10L5%205z%22%20fill-rule%3D%22evenodd%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\");--select-menu-background-color:linear-gradient(\n      to left,\n      var(--color-selected) 2rem,\n      var(--color-background) 2rem\n  );--select-menu-border-color:var(--color-active)}.hidden,:host([hidden]){display:none}label{display:inline-block;margin-bottom:10px;color:var(--select-menu-label-color);font-family:var(--font-body-1-font-family);font-size:var(--font-body-1-font-size);font-weight:var(--font-body-1-font-weight);letter-spacing:var(--font-body-1-letter-spacing)}.rux-select{position:relative;appearance:none;-webkit-appearance:none;-moz-appearance:none;width:100%;border:1px solid var(--select-menu-border-color);border-radius:var(--select-menu-border-radius);color:var(--select-menu-text-color);font-family:var(--font-body-1-font-family);font-size:var(--font-body-1-font-size);font-weight:var(--font-body-1-font-weight);letter-spacing:var(--font-body-1-letter-spacing);padding:0.438rem 3.125rem 0.438rem 0.5rem;background-image:var(--select-menu-inactive-caret), var(--select-menu-background-color);background-position:center right 0.625rem, center left 0;background-repeat:no-repeat;user-select:none}.rux-select:hover{cursor:pointer;border:1px solid var(--select-menu-border-hover-color)}.rux-select:active:not(:disabled){background-image:var(--select-menu-active-caret), var(--select-menu-background-color)}.rux-select:focus{outline:none;border:1px solid var(--select-menu-border-focus-color)}.rux-select:disabled{opacity:0.4;cursor:not-allowed}.rux-select:disabled:hover{border:1px solid var(--select-menu-border-color)}.rux-select.rux-select-invalid{border:1px solid var(--select-menu-invalid-border-color)}.rux-select::-ms-expand{display:none}.rux-select:focus::-ms-value{background:transparent}.rux-select option{opacity:1;color:var(--select-menu-text-color);border-radius:0;box-shadow:0 1px 3px 1px rgba(0, 0, 0, 0.5)}.rux-select option:hover{color:var(--select-menu-option-text-hover-color);background-color:var(--select-menu-option-hover-background-color)}.rux-select option:focus{color:var(--select-menu-option-selected-text-color);background-color:var(--select-menu-option-selected-background-color)}";

const RuxSelect = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.ruxSelectChanged = createEvent(this, "ruxchange", 7);
    this.ruxBlur = createEvent(this, "ruxblur", 7);
    this.hasLabelSlot = false;
    /**
     * Disables the select menu via HTML disabled attribute. Select menu takes on a distinct visual state. Cursor uses the not-allowed system replacement and all keyboard and mouse events are ignored.
     */
    this.disabled = false;
    /**
     * Sets the field as required
     */
    this.required = false;
    /**
     * Presentational only. Renders the Select Menu as invalid.
     */
    this.invalid = false;
    /**
     * Sets the Name of the Input Element
     */
    this.name = '';
    this._onBlur = () => {
      this.ruxBlur.emit();
    };
  }
  onValueChange() {
    this._syncOptionsFromValue();
  }
  handleLabelChange() {
    this._handleLabelSlotChange();
  }
  handleGroupChange() {
    this._syncOptionsToNativeSelect();
  }
  handleOptionChange() {
    this._syncOptionsToNativeSelect();
  }
  connectedCallback() {
    this._handleSlotChange = this._handleSlotChange.bind(this);
    this._handleLabelSlotChange = this._handleLabelSlotChange.bind(this);
  }
  componentWillLoad() {
    this._handleLabelSlotChange();
    if (this.value) {
      this._handleSlotChange();
    }
  }
  get hasLabel() {
    return this.label ? true : this.hasLabelSlot;
  }
  _handleLabelSlotChange() {
    this.hasLabelSlot = hasSlot(this.el, 'label');
  }
  async _handleSlotChange() {
    await this._syncOptionsToNativeSelect();
    await this._syncOptionsFromValue();
  }
  /**
   * The native select element doesn't play nicely with slots. If an <option> isn't a direct child element, it won't render properly.
   * As a solution, we expose a slot outside the shadow-DOMed <select> and then manually copy the contents inside the shadow DOM.
   *
   * A RuxOptionGroup component is required because onSlotchange won't fire if we use the native <optgroup> and we change just its options.
   * RuxOptionGroup exists only to fire a change event that we can listen to.
   */
  _syncOptionsToNativeSelect() {
    var _a;
    const slot = (_a = this.slotContainer) === null || _a === void 0 ? void 0 : _a.querySelector('slot');
    if (slot) {
      this.selectEl.innerHTML = '';
      const assignedElements = slot.assignedElements({
        flatten: true,
      });
      assignedElements.map((item) => {
        const option = item;
        if (option.tagName.toLowerCase() === 'rux-option') {
          this._appendOptionToNativeSelect(option.label, option.value, this.selectEl);
        }
        if (option.tagName.toLowerCase() === 'rux-option-group') {
          const children = [
            ...Array.from(option.querySelectorAll('rux-option')),
          ];
          this._appendOptGroupToNativeSelect(option.label ? option.label : 'Group', children);
        }
      });
    }
    return Promise.resolve();
  }
  _appendOptGroupToNativeSelect(groupName, children) {
    const group = Object.assign(document.createElement('optgroup'), {
      label: groupName,
    });
    children.map((option) => {
      this._appendOptionToNativeSelect(option.label, option.value, group);
      this.selectEl.appendChild(group);
    });
    this.selectEl.appendChild(group);
  }
  _appendOptionToNativeSelect(label, value, target) {
    const item = Object.assign(document.createElement('option'), {
      innerHTML: label ? label : '',
      value: value,
    });
    target.appendChild(item);
  }
  _syncOptionsFromValue() {
    if (this.selectEl) {
      const options = [
        ...Array.from(this.selectEl.querySelectorAll('option')),
      ];
      options.map((option) => {
        option.selected = option.value === this.value;
      });
    }
    return Promise.resolve();
  }
  _onChange(e) {
    const target = e.target;
    this.value = target.value;
    this.ruxSelectChanged.emit();
  }
  render() {
    const { disabled, required, label, inputId, labelId, invalid, name, } = this;
    renderHiddenInput(true, this.el, this.name, this.value, this.disabled);
    return (h(Host, null, h("label", { id: labelId, htmlFor: inputId, "aria-hidden": this.hasLabel ? 'false' : 'true' }, h("span", { class: { hidden: !this.hasLabel } }, h("slot", { onSlotchange: this._handleLabelSlotChange, name: "label" }, label))), h("select", { class: 'rux-select ' + (invalid ? 'rux-select-invalid' : ''), ref: (el) => (this.selectEl = el), id: inputId, disabled: disabled, required: required, name: name, onChange: (e) => this._onChange(e), onBlur: this._onBlur }), h("div", { "aria-hidden": "true", class: "hidden", ref: (el) => (this.slotContainer = el) }, h("slot", { onSlotchange: this._handleSlotChange })), h(FormFieldMessage, { errorText: this.errorText, helpText: this.helpText })));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "value": ["onValueChange"],
    "label": ["handleLabelChange"]
  }; }
};
RuxSelect.style = ruxSelectCss;

export { RuxSelect as rux_select };
