import { r as registerInstance, c as createEvent, h, g as getElement } from './index-01dd0ed8.js';

const ruxRadioCss = ":host{display:inline-block;box-sizing:border-box;--radio-hover-border-color:var(--color-hover);--radio-border-color:var(--color-active);--radio-label-color:var(--color-default-text);--radio-background-color:var(--color-background);--radio-selected-color:var(--color-primary)}:host *,:host *::before,:host *::after{box-sizing:inherit}.rux-form-field{display:flex;flex-direction:column;font-family:var(--font-body-1-font-family);font-size:var(--font-body-1-font-size);letter-spacing:var(--font-body-1-letter-spacing);font-weight:var(--font-body-1-font-weight);color:var(--color-default-text)}.rux-radio{display:flex;position:relative;line-height:1.2}.rux-radio input[type=radio]{-webkit-appearance:none;appearance:none}.rux-radio input[type=radio]+label{position:relative;display:flex;align-items:center;justify-content:flex-start;margin-left:-8px;color:var(--radio-label-color);letter-spacing:0.5px;cursor:pointer}.rux-radio input[type=radio]+label::before{box-sizing:border-box;display:flex;flex-shrink:0;flex-grow:0;content:\"\";align-self:start;height:1.125rem;width:1.125rem;margin:0 0.625rem 0 0;border:1px solid var(--radio-border-color);border-radius:var(--radius-circle);background-color:var(--radio-background-color)}.rux-radio input[type=radio]+label::after{position:absolute;top:5px;display:flex;content:\"\"}.rux-radio input[type=radio]:checked+label::before{background-color:var(--radio-background-color);border-color:var(--radio-border-color)}.rux-radio input[type=radio]:checked+label::after{position:absolute;top:5px;display:flex;content:\"\";left:5px;height:8px;width:8px;border-radius:var(--radius-circle);background-color:var(--color-primary)}.rux-radio input[type=radio]:disabled+label{cursor:not-allowed;opacity:var(--disabled-opacity)}.rux-radio input[type=radio]:not(:disabled):hover+label::before,.rux-radio input[type=radio]:not(:disabled):checked:hover+label::before{border-color:var(--radio-hover-border-color)}.rux-radio input[type=radio]:not(:disabled):hover+label::after,.rux-radio input[type=radio]:not(:disabled):checked:hover+label::after{background-color:var(--radio-selected-color)}:host([hidden]){display:none}";

let id = 0;
const RuxRadio = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.ruxBlur = createEvent(this, "ruxblur", 7);
    this.radioId = `rux-radio-${++id}`;
    this.radioGroup = null;
    /**
     * The radio name
     */
    this.name = '';
    /**
     * The radio value
     */
    this.value = '';
    /**
     * Toggles checked state of a radio
     */
    this.checked = false;
    /**
     * Disables the radio via HTML disabled attribute. Radio takes on a distinct visual state. Cursor uses the not-allowed system replacement and all keyboard and mouse events are ignored.
     */
    this.disabled = false;
    this._onBlur = () => {
      this.ruxBlur.emit();
    };
  }
  connectedCallback() {
    this._onChange = this._onChange.bind(this);
    this.radioGroup = this.el.closest('rux-radio-group');
    this._syncFromGroup = this._syncFromGroup.bind(this);
    if (this.radioGroup) {
      this._syncFromGroup();
      this.radioGroup.addEventListener('ruxchange', this._syncFromGroup);
    }
  }
  disconnectedCallback() {
    if (this.radioGroup) {
      this.radioGroup.removeEventListener('ruxchange', this._syncFromGroup);
    }
  }
  /**
   * Sets checked property when the parent Radio Group value changes.
   */
  _syncFromGroup() {
    if (this.radioGroup && this.radioGroup.value) {
      this.checked = this.radioGroup.value === this.value;
    }
  }
  _onChange(e) {
    const target = e.target;
    this.checked = target.checked;
  }
  render() {
    const { label, radioId, checked, disabled, name, value, _onChange, _onBlur, } = this;
    return (h("div", { class: "rux-form-field" }, h("div", { class: "rux-radio" }, h("input", { type: "radio", name: name, id: radioId, disabled: disabled, checked: checked, value: value, onChange: _onChange, onBlur: _onBlur }), h("label", { htmlFor: radioId }, h("slot", null, label)))));
  }
  get el() { return getElement(this); }
};
RuxRadio.style = ruxRadioCss;

export { RuxRadio as rux_radio };
