import { attachShadow, createEvent, h, Host, proxyCustomElement } from '@stencil/core/internal/client';

const ruxPopUpMenuCss = ":host{display:block;--popup-menu-background-color:var(--color-background);--popup-menu-border-color:var(--color-active);--popup-menu-caret-background-color:var(--color-active);--popup-menu-caret-left:2px;--popup-menu-caret-size:1.875rem;--popup-menu-transition-speed:0.1667s;opacity:0;margin:0;padding:0;position:absolute;pointer-events:none;color:var(--color-primary);background-color:var(--popup-menu-border-color);border:1px solid var(--popup-menu-border-color);border-top-width:4px;z-index:10000;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border-radius:var(--radius-base);top:-9999rem;left:-9999rem;transition:opacity 0.1667s ease-out;filter:drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5))}:host([hidden]){display:none}:host([open]){pointer-events:auto;opacity:1;transition:opacity 0.1667s ease-in}:host::after{content:\"\";display:block;position:absolute;z-index:1;border:8px solid transparent;border-bottom:11px solid var(--popup-menu-caret-background-color);left:var(--popup-menu-caret-left, 2px);top:-1.4375rem}ul{position:relative;list-style:none;padding:0;margin:0;background-color:var(--popup-menu-background-color);z-index:2;border-radius:2px}li:last-of-type{border:none;border-radius:0 0 2px 2px}li:first-of-type{border:none;border-radius:2px 2px 0 0}:host(.from-top){border-top-width:1px;border-bottom-width:4px}:host(.from-top)::after{top:unset;bottom:-23px;transform:rotate(180deg)}";

const RuxPopUpMenu$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.ruxMenuWillOpen = createEvent(this, "ruxmenuwillopen", 7);
    this.ruxMenuWillClose = createEvent(this, "ruxmenuwillclose", 7);
    this.ruxMenuDidOpen = createEvent(this, "ruxmenudidopen", 7);
    this.ruxMenuDidClose = createEvent(this, "ruxmenudidclose", 7);
    /**
     * Boolean which controls when to show the menu
     */
    this.open = false;
  }
  tieElements() {
    this._bindElements();
  }
  openMenu() {
    this._toggleOpenClose();
  }
  componentDidRender() {
    if (this.open) {
      this._setMenuPosition();
    }
  }
  connectedCallback() {
    this._handleClick = this._handleClick.bind(this);
    this._handleOutsideClick = this._handleOutsideClick.bind(this);
    this._bindElements();
    this._toggleOpenClose();
  }
  disconnectedCallback() {
    if (this.triggerEl) {
      this.triggerEl.removeEventListener('mousedown', this._handleClick);
    }
  }
  /**
   * Returns 'true' if the menu is open, 'false' if it is not.
   */
  async isOpen() {
    return this.open;
  }
  /**
   * Opens the menu. If the menu is already open it returns 'false'.
   */
  async show() {
    if (this.open) {
      return false;
    }
    this.open = true;
    return true;
  }
  /**
   * Closes the menu. If the menu is already closed it returns 'false'.
   */
  async close() {
    if (!this.open) {
      return false;
    }
    this.open = false;
    return true;
  }
  /**
   * Toggles the menu open or close. Will return 'true' on menu open and 'false' on menu close
   */
  async toggle() {
    this.open = !this.open;
    return this.open;
  }
  handleListen() {
    this.open = false;
  }
  _bindElements() {
    // find and set triggerEl from aria-controls if not given
    if (!this.triggerEl) {
      const triggerEl = document.querySelector(`[aria-controls="${this.el.id}"]`);
      if (triggerEl) {
        this.triggerEl = triggerEl;
        this.triggerEl.addEventListener('mousedown', this._handleClick);
      }
    }
    else {
      this.triggerEl.addEventListener('mousedown', this._handleClick);
    }
    // If a trigger element exists but no anchor, assign trigger to anchor
    if (!this.anchorEl && this.triggerEl) {
      this.anchorEl = this.triggerEl;
      this.anchorBounds = this.anchorEl.getBoundingClientRect();
    }
    else if (this.anchorEl) {
      this.anchorBounds = this.anchorEl.getBoundingClientRect();
    }
    this.menuBounds = this.el.getBoundingClientRect();
  }
  _setMenuPosition() {
    if (this.anchorEl && this.anchorBounds && this.menuBounds) {
      let { anchorBounds, menuBounds } = this;
      anchorBounds = this.anchorEl.getBoundingClientRect();
      menuBounds = this.el.getBoundingClientRect();
      const caret = parseInt(getComputedStyle(this.el, ':after').height);
      let top;
      let left;
      let caretLeft;
      const padding = 8;
      if (menuBounds.width + anchorBounds.left - padding >
        window.innerWidth) {
        left = anchorBounds.right - menuBounds.width;
        caretLeft = menuBounds.width - 25;
      }
      else if (anchorBounds.left - padding > 0) {
        left = anchorBounds.left - padding;
        caretLeft = 10;
      }
      else {
        left = padding;
        caretLeft = 10;
      }
      top =
        anchorBounds.bottom +
          padding / 2 +
          19 / 2; /* changed caret ref to 19 for bug fix */
      if (menuBounds.height + anchorBounds.bottom + padding >
        window.innerHeight) {
        top = anchorBounds.top - menuBounds.height - caret;
        this.el.classList.add('from-top');
      }
      else {
        this.el.classList.remove('from-top');
      }
      this.el.style.left = `${left}px`;
      this.el.style.top = `${top}px`;
      this.el.style.setProperty('--popup-menu-caret-left', `${caretLeft}px`);
    }
  }
  _handleClick(e) {
    e.preventDefault();
    this.open = true;
  }
  _handleOutsideClick(e) {
    const menuClick = e.composedPath().includes(this.el);
    if (!menuClick) {
      this.open = false;
    }
  }
  _toggleOpenClose() {
    var _a, _b;
    if (this.open) {
      if (!this.anchorEl) {
        this.open = false;
        console.error('Unable to open pop up menu without an anchor element. See documentation');
        return;
      }
      this.ruxMenuWillOpen.emit();
      const debounce = setTimeout(() => {
        window.addEventListener('resize', () => this._setMenuPosition());
        window.addEventListener('mousedown', this._handleOutsideClick);
        clearTimeout(debounce);
      }, 10);
      (_a = this.triggerEl) === null || _a === void 0 ? void 0 : _a.removeEventListener('mousedown', this._handleClick);
      this.ruxMenuDidOpen.emit();
    }
    else {
      this.ruxMenuWillClose.emit();
      window.removeEventListener('mousedown', this._handleOutsideClick);
      window.removeEventListener('resize', this._setMenuPosition);
      (_b = this.triggerEl) === null || _b === void 0 ? void 0 : _b.addEventListener('mousedown', this._handleClick);
      this.ruxMenuDidClose.emit();
    }
  }
  render() {
    return (h(Host, { "aria-hidden": !this.open ? 'true' : 'false' }, h("ul", { role: "menu", "aria-expanded": `${this.open}` }, h("slot", null)), h("slot", { name: "menu-end" })));
  }
  get el() { return this; }
  static get watchers() { return {
    "triggerEl": ["tieElements"],
    "anchorEl": ["tieElements"],
    "open": ["openMenu"]
  }; }
  static get style() { return ruxPopUpMenuCss; }
};

const RuxPopUpMenu = /*@__PURE__*/proxyCustomElement(RuxPopUpMenu$1, [1,"rux-pop-up-menu",{"triggerEl":[1040],"anchorEl":[1040],"open":[1540],"anchorBounds":[32],"menuBounds":[32]},[[0,"ruxmenuitemselected","handleListen"]]]);

export { RuxPopUpMenu };
