import { attachShadow, createEvent, h, Host, proxyCustomElement } from '@stencil/core/internal/client';

const ruxTreeNodeCss = ":host{--tree-accent-color:var(--color-primary);--tree-hover-background-color:var(--color-hover);--tree-hover-text-color:var(--color-inverse-text);--tree-selected-border-color:var(--color-primary-alt);--tree-selected-accent-color:var(--color-primary);--tree-expanded-border-color:var(--color-background);position:relative;box-sizing:border-box;width:100%;padding:0;margin:0;font-family:var(--font-body-1-font-family);font-size:var(--font-body-1-font-size);font-weight:var(--font-body-1-font-weight);letter-spacing:var(--font-body-1-letter-spacing);color:var(--tree-text-color);user-select:none;display:block}:host([hidden]){display:none}:host([aria-expanded=true][aria-level=\"1\"]:not([aria-selected=true])) .parent::after{border-bottom:solid 1px var(--tree-expanded-border-color)}:host([aria-selected=true]) .parent::after{content:\"\";height:30px;width:100%;left:0;z-index:0;position:absolute;transition:background-color 0.0967s ease-in 0s;border-top:1px solid var(--tree-selected-border-color);border-bottom:1px solid var(--tree-selected-border-color);box-shadow:inset 0.25rem 0 0 var(--tree-selected-accent-color) !important}:host([aria-level=\"1\"]) .parent{font-weight:bold;padding-left:0.5rem}:host([aria-level=\"1\"]) .parent::after{content:\"\";height:31px;width:100%;left:0;z-index:0;position:absolute;transition:background-color 0.0967s ease-in 0s}:host([aria-level=\"1\"]) .tree-node:not(.tree-node--has-children) .parent{padding-left:2rem}:host([aria-level=\"2\"]) .tree-node:not(.tree-node--has-children) .parent{padding-left:3.5rem}:host([aria-level=\"3\"]) .tree-node:not(.tree-node--has-children) .parent{padding-left:5rem}:host([aria-level=\"3\"]) .parent{padding-left:3.5rem}:host([aria-level=\"4\"]) .tree-node:not(.tree-node--has-children) .parent{padding-left:6.5rem}:host([aria-level=\"4\"]) .parent{padding-left:5rem}.parent{height:2rem;padding:0 0.5rem 0 2rem;display:flex;align-items:center}.parent:hover{color:var(--tree-hover-text-color);background:var(--tree-hover-background-color)}.children{display:none}.tree-node--expanded>.children{display:block !important}.tree-node--expanded .arrow{transform:rotate(90deg)}.arrow{position:relative;cursor:pointer;width:0.35rem;margin-right:1rem;margin-left:0.15rem;background-color:transparent;transition:transform 0.167s ease-in-out 0s;z-index:11}.arrow::before{content:\"\";display:block;height:1.5rem;width:1.5rem;top:-0.15rem;left:-0.65rem;position:absolute}.arrow::after{content:\"\";width:0;height:0;border-style:solid;border-width:0.35rem 0 0.35rem 0.35rem;border-color:transparent transparent transparent var(--tree-accent-color);display:inline-block}::slotted(rux-status){margin:0 0.625rem}::slotted(rux-tree-node){position:relative}::slotted(rux-tree-node)::before{content:\"\";order:1;position:absolute;top:0;cursor:pointer;width:20px;height:20px;margin-right:1rem;margin-left:0.15rem;left:-40px;background-color:transparent;transition:transform 0.167s ease-in-out 0s;z-index:11}";

let id = 0;
const RuxTreeNode$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.ruxTreeNodeSelected = createEvent(this, "ruxtreenodeselected", 7);
    this.componentId = `node-${++id}`;
    this.children = [];
    /**
     * Sets the expanded state
     */
    this.expanded = false;
    /**
     * Sets the selected state
     */
    this.selected = false;
  }
  handleExpandedChange(newValue) {
    this.setExpanded(newValue);
  }
  handleSelectedChange(newValue) {
    this.setSelected(newValue);
  }
  handleKeyDown(ev) {
    if (ev.target !== ev.currentTarget) {
      return true;
    }
    switch (ev.key) {
      case 'ArrowUp':
        ev.preventDefault();
        this._focusNext(-1);
        break;
      case 'ArrowRight':
        ev.preventDefault();
        this._expandNextNode();
        break;
      case 'ArrowDown':
        ev.preventDefault();
        this._focusNext(1);
        break;
      case 'ArrowLeft':
        ev.preventDefault();
        this._collapseParent();
        break;
      case 'Enter':
        ev.preventDefault();
        this.setSelected(true);
        break;
    }
  }
  connectedCallback() {
    this._handleSlotChange = this._handleSlotChange.bind(this);
  }
  componentWillLoad() {
    this._handleSlotChange();
  }
  get _hasChildren() {
    return this.children.length > 0;
  }
  /**
   * Sets the expanded state
   * @param value
   */
  async setExpanded(value) {
    this.expanded = value;
  }
  /**
   * Sets the selected state
   * @param value
   */
  async setSelected(value) {
    this.selected = value;
    if (value) {
      this.ruxTreeNodeSelected.emit(this.componentId);
    }
  }
  _handleSlotChange() {
    const children = Array.from(this.el.querySelectorAll(`[slot="node"]`));
    this.children = children;
    this._setAriaLevel();
  }
  /**
   * Manually set the aria-level attribute.
   * Tree is responsible for setting the root node levels.
   */
  _setAriaLevel() {
    const level = this.el.getAttribute('aria-level');
    if (level) {
      this.children.map((child) => {
        child.setAttribute('aria-level', `${+level + 1}`);
      });
    }
  }
  _handleArrowClick(e) {
    e.stopPropagation();
    this.setExpanded(!this.expanded);
  }
  _handleTreeNodeClick(e) {
    e.stopPropagation();
    this.selected = !this.selected;
  }
  _expandNextNode() {
    if (!this.expanded && this._hasChildren) {
      this.setExpanded(true);
    }
  }
  _focusItem(el) {
    var _a;
    const parent = (_a = el === null || el === void 0 ? void 0 : el.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('.parent');
    if (parent) {
      parent.focus();
    }
  }
  _collapseParent() {
    if (this.expanded) {
      this.setExpanded(false);
    }
    else if (this.el.parentElement) {
      const parentTreeItemNode = this.el.parentElement.closest("[role='treeitem']");
      if (parentTreeItemNode) {
        this._focusItem(parentTreeItemNode);
      }
    }
  }
  _focusNext(direction) {
    const visibleNodes = this._getVisibleNodes();
    const currentIndex = visibleNodes.indexOf(this.el);
    console.log('start focus');
    if (currentIndex !== -1) {
      let nextElement = visibleNodes[currentIndex + direction];
      if (nextElement !== undefined) {
        // Skips any disabled nodes
        while (nextElement.hasAttribute('disabled')) {
          const offset = direction >= 0 ? 1 : -1;
          nextElement =
            visibleNodes[currentIndex + direction + offset];
          if (nextElement) {
            break;
          }
        }
      }
      if (nextElement !== null) {
        this._focusItem(nextElement);
      }
    }
  }
  _getVisibleNodes() {
    const rootTree = this.el.closest("[role='tree']");
    const nodes = Array.from(rootTree.querySelectorAll('rux-tree-node'));
    return nodes.filter((node) => node.offsetParent !== null);
  }
  render() {
    const attrs = this._hasChildren && { role: 'group' };
    return (h(Host, { role: "treeitem", "aria-expanded": this.expanded ? 'true' : 'false', "aria-selected": this.selected ? 'true' : 'false', onClick: (event) => this._handleTreeNodeClick(event) }, h("div", { id: this.componentId, class: {
        'tree-node': true,
        'tree-node--expanded': this.expanded,
        'tree-node--has-children': this._hasChildren,
        'tree-node--selected': this.selected,
      } }, h("div", { class: "parent", tabindex: "0" }, this._hasChildren && (h("i", { onClick: (e) => this._handleArrowClick(e), class: "arrow" })), h("slot", { onSlotchange: this._handleSlotChange })), h("div", Object.assign({}, attrs, { class: "children" }), h("slot", { name: "node", onSlotchange: this._handleSlotChange })))));
  }
  get el() { return this; }
  static get watchers() { return {
    "expanded": ["handleExpandedChange"],
    "selected": ["handleSelectedChange"]
  }; }
  static get style() { return ruxTreeNodeCss; }
};

const RuxTreeNode = /*@__PURE__*/proxyCustomElement(RuxTreeNode$1, [1,"rux-tree-node",{"expanded":[1540],"selected":[1540],"children":[32]},[[1,"keydown","handleKeyDown"]]]);

export { RuxTreeNode };
