import { attachShadow, h, Host, proxyCustomElement } from '@stencil/core/internal/client';

const ruxTreeCss = ":host{--tree-text-color:var(--color-default-text);--tree-background-color:var(--color-surface);--tree-border-color:var(--color-primary-alt);display:block;position:relative;box-sizing:border-box;padding:0;font-family:var(--font-body-1-font-family);font-size:var(--font-body-1-font-size);font-weight:var(--font-body-1-font-weight);letter-spacing:var(--font-body-1-letter-spacing);color:var(--tree-text-color);border:solid 1px var(--tree-border-color);background-color:var(--tree-background-color);user-select:none;width:100%}:host([hidden]){display:none}";

const RuxTree$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
  }
  connectedCallback() {
    this._handleSlotChange = this._handleSlotChange.bind(this);
    this._handleNodeSelected = this._handleNodeSelected.bind(this);
  }
  disconnectedCallback() {
    var _a;
    const slot = (_a = this.slotContainer) === null || _a === void 0 ? void 0 : _a.querySelector('slot');
    const assignedElements = slot.assignedElements({
      flatten: true,
    });
    assignedElements.map((el) => {
      el.removeEventListener('ruxtreenodeselected', this._handleNodeSelected);
    });
  }
  _handleSlotChange() {
    var _a;
    const slot = (_a = this.slotContainer) === null || _a === void 0 ? void 0 : _a.querySelector('slot');
    const assignedElements = slot.assignedElements({
      flatten: true,
    });
    assignedElements.map((el) => {
      el.setAttribute('aria-level', '1');
      el.addEventListener('ruxtreenodeselected', this._handleNodeSelected);
    });
  }
  _handleNodeSelected(e) {
    const allNodes = document.querySelectorAll('rux-tree-node');
    const previousSelectedNode = Array.from(allNodes).find((node) => {
      var _a, _b;
      return (node.selected &&
        ((_b = (_a = node.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('.tree-node')) === null || _b === void 0 ? void 0 : _b.id) !== e.detail);
    });
    if (previousSelectedNode) {
      previousSelectedNode.selected = false;
    }
  }
  render() {
    return (h(Host, { role: "tree" }, h("div", { ref: (el) => (this.slotContainer = el) }, h("slot", { onSlotchange: this._handleSlotChange }))));
  }
  get el() { return this; }
  static get style() { return ruxTreeCss; }
};

const RuxTree = /*@__PURE__*/proxyCustomElement(RuxTree$1, [1,"rux-tree"]);

export { RuxTree };
