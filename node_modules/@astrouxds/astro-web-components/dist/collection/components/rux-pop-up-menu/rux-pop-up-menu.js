import { Component, Host, h, Prop, Element, Event, Method, Watch, State, Listen, } from '@stencil/core';
/**
 * @slot menu-end - Area below the menu list to insert elements. For example, confirmation and/or cancel button group.
 */
export class RuxPopUpMenu {
  constructor() {
    /**
     * Boolean which controls when to show the menu
     */
    this.open = false;
  }
  tieElements() {
    this._bindElements();
  }
  openMenu() {
    this._toggleOpenClose();
  }
  componentDidRender() {
    if (this.open) {
      this._setMenuPosition();
    }
  }
  connectedCallback() {
    this._handleClick = this._handleClick.bind(this);
    this._handleOutsideClick = this._handleOutsideClick.bind(this);
    this._bindElements();
    this._toggleOpenClose();
  }
  disconnectedCallback() {
    if (this.triggerEl) {
      this.triggerEl.removeEventListener('mousedown', this._handleClick);
    }
  }
  /**
   * Returns 'true' if the menu is open, 'false' if it is not.
   */
  async isOpen() {
    return this.open;
  }
  /**
   * Opens the menu. If the menu is already open it returns 'false'.
   */
  async show() {
    if (this.open) {
      return false;
    }
    this.open = true;
    return true;
  }
  /**
   * Closes the menu. If the menu is already closed it returns 'false'.
   */
  async close() {
    if (!this.open) {
      return false;
    }
    this.open = false;
    return true;
  }
  /**
   * Toggles the menu open or close. Will return 'true' on menu open and 'false' on menu close
   */
  async toggle() {
    this.open = !this.open;
    return this.open;
  }
  handleListen() {
    this.open = false;
  }
  _bindElements() {
    // find and set triggerEl from aria-controls if not given
    if (!this.triggerEl) {
      const triggerEl = document.querySelector(`[aria-controls="${this.el.id}"]`);
      if (triggerEl) {
        this.triggerEl = triggerEl;
        this.triggerEl.addEventListener('mousedown', this._handleClick);
      }
    }
    else {
      this.triggerEl.addEventListener('mousedown', this._handleClick);
    }
    // If a trigger element exists but no anchor, assign trigger to anchor
    if (!this.anchorEl && this.triggerEl) {
      this.anchorEl = this.triggerEl;
      this.anchorBounds = this.anchorEl.getBoundingClientRect();
    }
    else if (this.anchorEl) {
      this.anchorBounds = this.anchorEl.getBoundingClientRect();
    }
    this.menuBounds = this.el.getBoundingClientRect();
  }
  _setMenuPosition() {
    if (this.anchorEl && this.anchorBounds && this.menuBounds) {
      let { anchorBounds, menuBounds } = this;
      anchorBounds = this.anchorEl.getBoundingClientRect();
      menuBounds = this.el.getBoundingClientRect();
      const caret = parseInt(getComputedStyle(this.el, ':after').height);
      let top;
      let left;
      let caretLeft;
      const padding = 8;
      if (menuBounds.width + anchorBounds.left - padding >
        window.innerWidth) {
        left = anchorBounds.right - menuBounds.width;
        caretLeft = menuBounds.width - 25;
      }
      else if (anchorBounds.left - padding > 0) {
        left = anchorBounds.left - padding;
        caretLeft = 10;
      }
      else {
        left = padding;
        caretLeft = 10;
      }
      top =
        anchorBounds.bottom +
          padding / 2 +
          19 / 2; /* changed caret ref to 19 for bug fix */
      if (menuBounds.height + anchorBounds.bottom + padding >
        window.innerHeight) {
        top = anchorBounds.top - menuBounds.height - caret;
        this.el.classList.add('from-top');
      }
      else {
        this.el.classList.remove('from-top');
      }
      this.el.style.left = `${left}px`;
      this.el.style.top = `${top}px`;
      this.el.style.setProperty('--popup-menu-caret-left', `${caretLeft}px`);
    }
  }
  _handleClick(e) {
    e.preventDefault();
    this.open = true;
  }
  _handleOutsideClick(e) {
    const menuClick = e.composedPath().includes(this.el);
    if (!menuClick) {
      this.open = false;
    }
  }
  _toggleOpenClose() {
    var _a, _b;
    if (this.open) {
      if (!this.anchorEl) {
        this.open = false;
        console.error('Unable to open pop up menu without an anchor element. See documentation');
        return;
      }
      this.ruxMenuWillOpen.emit();
      const debounce = setTimeout(() => {
        window.addEventListener('resize', () => this._setMenuPosition());
        window.addEventListener('mousedown', this._handleOutsideClick);
        clearTimeout(debounce);
      }, 10);
      (_a = this.triggerEl) === null || _a === void 0 ? void 0 : _a.removeEventListener('mousedown', this._handleClick);
      this.ruxMenuDidOpen.emit();
    }
    else {
      this.ruxMenuWillClose.emit();
      window.removeEventListener('mousedown', this._handleOutsideClick);
      window.removeEventListener('resize', this._setMenuPosition);
      (_b = this.triggerEl) === null || _b === void 0 ? void 0 : _b.addEventListener('mousedown', this._handleClick);
      this.ruxMenuDidClose.emit();
    }
  }
  render() {
    return (h(Host, { "aria-hidden": !this.open ? 'true' : 'false' },
      h("ul", { role: "menu", "aria-expanded": `${this.open}` },
        h("slot", null)),
      h("slot", { name: "menu-end" })));
  }
  static get is() { return "rux-pop-up-menu"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() { return {
    "$": ["rux-pop-up-menu.scss"]
  }; }
  static get styleUrls() { return {
    "$": ["rux-pop-up-menu.css"]
  }; }
  static get properties() { return {
    "triggerEl": {
      "type": "unknown",
      "mutable": true,
      "complexType": {
        "original": "HTMLElement",
        "resolved": "HTMLElement | undefined",
        "references": {
          "HTMLElement": {
            "location": "global"
          }
        }
      },
      "required": false,
      "optional": true,
      "docs": {
        "tags": [],
        "text": "Optional element to trigger opening and closing of the menu.\nIf none is supplied the element where aria-controls === menu id will be assigned"
      }
    },
    "anchorEl": {
      "type": "unknown",
      "mutable": true,
      "complexType": {
        "original": "HTMLElement",
        "resolved": "HTMLElement | undefined",
        "references": {
          "HTMLElement": {
            "location": "global"
          }
        }
      },
      "required": false,
      "optional": true,
      "docs": {
        "tags": [],
        "text": "Element to anchor the menu to. If none is given the menu will anchor\nto the trigger element where aria-controls === menu id"
      }
    },
    "open": {
      "type": "boolean",
      "mutable": true,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Boolean which controls when to show the menu"
      },
      "attribute": "open",
      "reflect": true,
      "defaultValue": "false"
    }
  }; }
  static get states() { return {
    "anchorBounds": {},
    "menuBounds": {}
  }; }
  static get events() { return [{
      "method": "ruxMenuWillOpen",
      "name": "ruxmenuwillopen",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": "Emitted when the menu is about to open."
      },
      "complexType": {
        "original": "void",
        "resolved": "void",
        "references": {}
      }
    }, {
      "method": "ruxMenuWillClose",
      "name": "ruxmenuwillclose",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": "Emitted when the menu is about to close"
      },
      "complexType": {
        "original": "void",
        "resolved": "void",
        "references": {}
      }
    }, {
      "method": "ruxMenuDidOpen",
      "name": "ruxmenudidopen",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": "Emitted when the menu is open."
      },
      "complexType": {
        "original": "void",
        "resolved": "void",
        "references": {}
      }
    }, {
      "method": "ruxMenuDidClose",
      "name": "ruxmenudidclose",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": "Emitted when the menu is closed."
      },
      "complexType": {
        "original": "void",
        "resolved": "void",
        "references": {}
      }
    }]; }
  static get methods() { return {
    "isOpen": {
      "complexType": {
        "signature": "() => Promise<boolean>",
        "parameters": [],
        "references": {
          "Promise": {
            "location": "global"
          }
        },
        "return": "Promise<boolean>"
      },
      "docs": {
        "text": "Returns 'true' if the menu is open, 'false' if it is not.",
        "tags": []
      }
    },
    "show": {
      "complexType": {
        "signature": "() => Promise<boolean>",
        "parameters": [],
        "references": {
          "Promise": {
            "location": "global"
          }
        },
        "return": "Promise<boolean>"
      },
      "docs": {
        "text": "Opens the menu. If the menu is already open it returns 'false'.",
        "tags": []
      }
    },
    "close": {
      "complexType": {
        "signature": "() => Promise<boolean>",
        "parameters": [],
        "references": {
          "Promise": {
            "location": "global"
          }
        },
        "return": "Promise<boolean>"
      },
      "docs": {
        "text": "Closes the menu. If the menu is already closed it returns 'false'.",
        "tags": []
      }
    },
    "toggle": {
      "complexType": {
        "signature": "() => Promise<boolean>",
        "parameters": [],
        "references": {
          "Promise": {
            "location": "global"
          }
        },
        "return": "Promise<boolean>"
      },
      "docs": {
        "text": "Toggles the menu open or close. Will return 'true' on menu open and 'false' on menu close",
        "tags": []
      }
    }
  }; }
  static get elementRef() { return "el"; }
  static get watchers() { return [{
      "propName": "triggerEl",
      "methodName": "tieElements"
    }, {
      "propName": "anchorEl",
      "methodName": "tieElements"
    }, {
      "propName": "open",
      "methodName": "openMenu"
    }]; }
  static get listeners() { return [{
      "name": "ruxmenuitemselected",
      "method": "handleListen",
      "target": undefined,
      "capture": false,
      "passive": false
    }]; }
}
